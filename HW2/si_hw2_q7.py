# -*- coding: utf-8 -*-
"""SI_HW2_Q7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L2STcnx4o4rWeeyFmQLc6DGVmzHVmmbV
"""

from google.colab import drive
drive.mount('/content/drive')

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# Specify the path to Excel file
file_path = '/content/drive/MyDrive/si/Problem 7 Data.xls'

# Read the Excel file
data = pd.read_excel(file_path)

plt.figure(figsize=(10, 6))
plt.hist(data['population'], bins=30, color='blue', edgecolor='black')
plt.title('Histogram of Population Values for Cancer Mortality')
plt.xlabel('Population')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()

# Calculating the mean and total of the population and mortalities
population_mean = data['population'].mean()
total_mortalities = data['mortalities'].sum()
mortalities_mean = data['mortalities'].mean()
mortalities_var = data['mortalities'].var()
# Calculating the variance and standard deviation of the population
population_variance = data['population'].var()
population_std_dev = data['population'].std()

output = (
    f"The mean population is {population_mean:,.2f}. " \n
    f"The total number of mortalities is {total_mortalities:,}. "
    f"The population variance is {population_variance:,.2f}, "
    f"The cancer mortality mean is {mortalities_mean:,.2f}, "
    f"The cancer mortality variance is {mortalities_var:,.2f}, "
    f"and the standard deviation of the population is {population_std_dev:,.2f}."
)

print(output)

import numpy as np

# Setting the sample sizet

sample_size = 25

# Simulating the sampling distribution of the mean
# We will use 1000 simulated samples to create the distribution
num_simulations = 1000
sample_means = [np.mean(np.random.choice(data['mortalities'], sample_size, replace=True)) for _ in range(num_simulations)]

# Plotting the distribution of sample means
plt.figure(figsize=(10, 6))
plt.hist(sample_means, bins=30, color='green', edgecolor='black')
plt.title('Sampling Distribution of the Mean for Cancer Mortality (Sample Size = 25)')
plt.xlabel('Sample Mean of Mortalities')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()

# Drawing a simple random sample of size 25 from the previously created data
sample = data.sample(n=25, random_state=1)

# Estimating the mean and total cancer mortality from the sample
estimated_mean = sample['mortalities'].mean()
estimated_total = sample['mortalities'].sum()

# Formatting the results for readability
formatted_output = (
    f"Estimated Mean Mortality: {estimated_mean:.2f}, "
    f"Estimated Total Mortality: {estimated_total}"
)

formatted_output

# Estimating the population variance and standard deviation from the sample
# Note: For an unbiased estimate of population variance, we use ddof=1
estimated_variance = sample['mortalities'].var(ddof=1)
estimated_std_dev = sample['mortalities'].std(ddof=1)

# Formatting the results for readability
formatted_variance_std_dev_output = (
    f"Estimated Population Variance: {estimated_variance:.2f}, "
    f"Estimated Population Standard Deviation: {estimated_std_dev:.2f}"
)

formatted_variance_std_dev_output

from scipy.stats import t

# Calculating the 95% confidence interval for the population mean
mean = sample['mortalities'].mean()
std_error = sample['mortalities'].std(ddof=1) / np.sqrt(sample_size)

# t-distribution critical value for 95% confidence
t_critical = t.ppf(0.975, df=sample_size-1) # two-tailed

confidence_interval_mean = (mean - t_critical * std_error, mean + t_critical * std_error)

# Estimating 95% confidence interval for the total cancer mortality
# Since total = mean * population size, we multiply the confidence interval of the mean by the population size
population_size = data['mortalities'].count()
confidence_interval_total = (confidence_interval_mean[0] * population_size, confidence_interval_mean[1] * population_size)

formatted_confidence_intervals = (
    f"95% Confidence Interval for Mean Mortality: ({confidence_interval_mean[0]:.2f}, {confidence_interval_mean[1]:.2f}), "
    f"95% Confidence Interval for Total Mortality: ({confidence_interval_total[0]:,.0f}, {confidence_interval_total[1]:,.0f})"
)

formatted_confidence_intervals

# Drawing a simple random sample of size 100
sample_size_100 = 100
sample_100 = data.sample(n=sample_size_100, random_state=2)

# Estimating the mean and total cancer mortality from the sample of size 100
estimated_mean_100 = sample_100['mortalities'].mean()
estimated_total_100 = sample_100['mortalities'].sum()

# Estimating the population variance and standard deviation from the sample of size 100
estimated_variance_100 = sample_100['mortalities'].var(ddof=1)
estimated_std_dev_100 = sample_100['mortalities'].std(ddof=1)

# Calculating the 95% confidence interval for the population mean for sample of size 100
std_error_100 = estimated_std_dev_100 / np.sqrt(sample_size_100)

# t-distribution critical value for 95% confidence
t_critical_100 = t.ppf(0.975, df=sample_size_100-1) # two-tailed

confidence_interval_mean_100 = (
    estimated_mean_100 - t_critical_100 * std_error_100,
    estimated_mean_100 + t_critical_100 * std_error_100
)

# Estimating 95% confidence interval for the total cancer mortality for sample of size 100
confidence_interval_total_100 = (
    confidence_interval_mean_100[0] * population_size,
    confidence_interval_mean_100[1] * population_size
)


formatted_results_sample_100 = (
    f"Estimated Mean Mortality (Sample of 100): {estimated_mean_100:.2f}, "
    f"Estimated Total Mortality (Sample of 100): {estimated_total_100}, "
    f"95% Confidence Interval for Mean Mortality (Sample of 100): ({confidence_interval_mean_100[0]:.2f}, {confidence_interval_mean_100[1]:.2f}), "
    f"95% Confidence Interval for Total Mortality (Sample of 100): ({confidence_interval_total_100[0]:,.0f}, {confidence_interval_total_100[1]:,.0f})"
)

formatted_results_sample_100

# Simulating the sampling distribution of ratio estimators for cancer mortality
# Based on a simple random sample of size 25

num_simulations = 1000
ratio_estimates = []

for _ in range(num_simulations):
    sample = data.sample(n=25)
    ratio_estimate = (sample['mortalities'].sum() / sample['population'].sum()) * data['population'].mean()
    ratio_estimates.append(ratio_estimate)

# Plotting the distribution of ratio estimates
plt.figure(figsize=(10, 6))
plt.hist(ratio_estimates, bins=30, color='purple', edgecolor='black', alpha=0.7, label='Ratio Estimators')
plt.hist(sample_means, bins=30, color='green', edgecolor='black', alpha=0.7, label='Sample Means')
plt.title('Sampling Distribution of Ratio Estimators vs. Sample Means')
plt.xlabel('Estimated Mean Cancer Mortality')
plt.ylabel('Frequency')
plt.legend()
plt.grid(True)
plt.show()

# Drawing a simple random sample of size 25
sample_25 = data.sample(n=25, random_state=3)

# Estimating the population mean and total cancer mortality in the usual way
usual_mean_estimate = sample_25['mortalities'].mean()
usual_total_estimate = sample_25['mortalities'].sum()

# Estimating the population mean and total cancer mortality using ratio estimates
ratio_mean_estimate = (sample_25['mortalities'].sum() / sample_25['population'].sum()) * data['population'].mean()
ratio_total_estimate = ratio_mean_estimate * population_size

formatted_results_sample_25 = (
    f"Usual Estimated Mean Mortality: {usual_mean_estimate:.2f}, "
    f"Usual Estimated Total Mortality: {usual_total_estimate}, "
    f"Ratio Estimated Mean Mortality: {ratio_mean_estimate:.2f}, "
    f"Ratio Estimated Total Mortality: {ratio_total_estimate:,.0f}"
)

formatted_results_sample_25

# Calculating the 95% confidence interval for the usual method estimates
# For the mean
usual_std_error = sample_25['mortalities'].std(ddof=1) / np.sqrt(25)
usual_t_critical = t.ppf(0.975, df=24) # two-tailed
usual_confidence_interval_mean = (
    usual_mean_estimate - usual_t_critical * usual_std_error,
    usual_mean_estimate + usual_t_critical * usual_std_error
)

# For the total (multiplying the confidence interval of the mean by the population size)
usual_confidence_interval_total = (
    usual_confidence_interval_mean[0] * population_size,
    usual_confidence_interval_mean[1] * population_size
)

# Calculating the 95% confidence interval for the ratio method estimates
# Approximating the standard error for the ratio estimate is more complex and often requires resampling techniques like bootstrapping
# Here, we'll perform a simple bootstrap to estimate the standard error
bootstrap_samples = 1000
bootstrap_estimates = []
for _ in range(bootstrap_samples):
    bootstrap_sample = data.sample(n=25, replace=True)
    bootstrap_ratio_estimate = (bootstrap_sample['mortalities'].sum() / bootstrap_sample['population'].sum()) * data['population'].mean()
    bootstrap_estimates.append(bootstrap_ratio_estimate)

bootstrap_std_error = np.std(bootstrap_estimates, ddof=1)
ratio_confidence_interval_mean = (
    ratio_mean_estimate - usual_t_critical * bootstrap_std_error,
    ratio_mean_estimate + usual_t_critical * bootstrap_std_error
)

# For the total (multiplying the confidence interval of the mean by the population size)
ratio_confidence_interval_total = (
    ratio_confidence_interval_mean[0] * population_size,
    ratio_confidence_interval_mean[1] * population_size
)


formatted_confidence_intervals = (
    f"Usual Method 95% Confidence Interval for Mean Mortality: ({usual_confidence_interval_mean[0]:.2f}, {usual_confidence_interval_mean[1]:.2f}), "
    f"Usual Method 95% Confidence Interval for Total Mortality: ({usual_confidence_interval_total[0]:,.0f}, {usual_confidence_interval_total[1]:,.0f}), "
    f"Ratio Method 95% Confidence Interval for Mean Mortality: ({ratio_confidence_interval_mean[0]:.2f}, {ratio_confidence_interval_mean[1]:.2f}), "
    f"Ratio Method 95% Confidence Interval for Total Mortality: ({ratio_confidence_interval_total[0]:,.0f}, {ratio_confidence_interval_total[1]:,.0f})"
)

formatted_confidence_intervals

# Stratifying the counties into four strata by population size
quantiles = data['population'].quantile([0.25, 0.5, 0.75])
strata = [
    data[data['population'] <= quantiles[0.25]],  # First quartile
    data[(data['population'] > quantiles[0.25]) & (data['population'] <= quantiles[0.5])],  # Second quartile
    data[(data['population'] > quantiles[0.5]) & (data['population'] <= quantiles[0.75])],  # Third quartile
    data[data['population'] > quantiles[0.75]]  # Fourth quartile
]

# Randomly sampling six observations from each stratum
sampled_data = [stratum.sample(n=6, random_state=4) for stratum in strata]

# Forming estimates of the population mean and total mortality
strata_means = [stratum_sample['mortalities'].mean() for stratum_sample in sampled_data]
strata_totals = [stratum_sample['mortalities'].sum() for stratum_sample in sampled_data]

formatted_strata_results = (
    f"Strata Means: {strata_means}, "
    f"Strata Totals: {strata_totals}"
)

formatted_strata_results

# Continued from the previous stratification
strata_sizes = [len(stratum) for stratum in strata]
total_population = sum(strata_sizes)

# Proportional allocation: Sampling fractions
total_sample_size = 100  # Example total sample size for calculation
proportional_allocation = [round((size / total_population) * total_sample_size) for size in strata_sizes]

# Optimal allocation: Requires stratum standard deviations
strata_std_devs = [stratum['mortalities'].std() for stratum in strata]
optimal_allocation = [round((size * std / sum([s * sd for s, sd in zip(strata_sizes, strata_std_devs)])) * total_sample_size)
                      for size, std in zip(strata_sizes, strata_std_devs)]

# Variance for simple random sampling
srs_variance = data['mortalities'].var()

# Variance for proportional allocation
prop_allocation_variance = sum([(size / total_population) ** 2 * stratum['mortalities'].var() / n
                                for stratum, size, n in zip(strata, strata_sizes, proportional_allocation)])

# Variance for optimal allocation
opt_allocation_variance = sum([(std / sum([s * sd for s, sd in zip(strata_sizes, strata_std_devs)])) ** 2 * stratum['mortalities'].var() / n
                                for stratum, std, n in zip(strata, strata_std_devs, optimal_allocation)])


formatted_sampling_results = (
    f"Strata Sizes: {strata_sizes}, "
    f"Proportional Allocation: {proportional_allocation}, "
    f"Optimal Allocation: {optimal_allocation}, "
    f"SRS Variance: {srs_variance:.2f}, "
    f"Proportional Allocation Variance: {prop_allocation_variance:.2f}, "
    f"Optimal Allocation Variance: {opt_allocation_variance:.2f}"
)

formatted_sampling_results

import pandas as pd

def stratified_sampling_variance(data, num_strata):
    """
    Function to perform stratified sampling and calculate the variance of the mean estimate
    for a given number of strata.
    """
    # Create strata based on quantiles
    quantiles = data['population'].quantile([i/num_strata for i in range(1, num_strata)])
    strata = [data[data['population'] <= quantiles.iloc[0]]]  # First stratum
    for i in range(1, num_strata - 1):
        strata.append(data[(data['population'] > quantiles.iloc[i-1]) & (data['population'] <= quantiles.iloc[i])])
    strata.append(data[data['population'] > quantiles.iloc[-1]])  # Last stratum

    # Calculate mean and variance for each stratum
    strata_means = [stratum['mortalities'].mean() for stratum in strata]
    strata_variances = [stratum['mortalities'].var(ddof=1) for stratum in strata]
    strata_sizes = [len(stratum) for stratum in strata]

    # Calculate overall mean and variance using proportional allocation
    overall_mean = sum([mean * size / total_population for mean, size in zip(strata_means, strata_sizes)])
    overall_variance = sum([var * (size / total_population) ** 2 for var, size in zip(strata_variances, strata_sizes)])

    return overall_variance

# Variances for different numbers of strata
total_population = len(data)
variances = {
    "4 Strata": stratified_sampling_variance(data, 4),
    "8 Strata": stratified_sampling_variance(data, 8),
    "16 Strata": stratified_sampling_variance(data, 16),
    "32 Strata": stratified_sampling_variance(data, 32),
    "64 Strata": stratified_sampling_variance(data, 64)
}

variances